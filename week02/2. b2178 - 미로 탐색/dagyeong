// 2. 미로 탐색(시험문제)
#if 0
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define SIZE(A) (sizeof(A)/sizeof(A[0]))
#define MAX (100+2)

int N, M;
int map[MAX][MAX];
int dr[4] = { -1, 1, 0, 0 };
int dc[4] = { 0, 0, -1, 1 };

typedef struct _node {
	int r, c;
}node_t;
node_t Queue[MAX * MAX];
int front, rear;

void inputData(void) {
	(void)scanf("%d %d", &N, &M);
	char temp[MAX] = { 0 };
	for (int i = 1; i <= N; ++i) {
		(void)scanf("%s", temp + 1);
		for (int j = 1; j <= M; ++j) {
			map[i][j] = temp[j] - '0';
		}
	}
}

int BFS() {
	int visited[MAX][MAX] = { 0 };
	node_t curr = { 0 };
	front = rear = 0;

	Queue[rear++] = (node_t){ 1, 1 }; //문제 시작점이 (1,1)로 고정
	visited[1][1] = 1;

	while (front != rear) {
		curr = Queue[front++];
		for (int i = 0; i < 4; ++i) {
			int nr = curr.r + dr[i];
			int nc = curr.c + dc[i];
			if (!map[nr][nc] || visited[nr][nc]) continue;
			else {
				Queue[rear++] = (node_t){ nr, nc };
				int newcnt = visited[curr.r][curr.c] + 1;
				//if (visited[nr][nc] > newcnt)
				visited[nr][nc] = newcnt;
			}
		}
	}
	return visited[N][M];
}

void printData(int (*ary)[MAX]) {
	for (int i = 1; i <= N; ++i) {
		for (int j = 1; j <= M; ++j) {
			printf("%d ", ary[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}

#define DEBUG 0
int main(void) {
#if DEBUG
	(void)freopen("b2178.txt", "r", stdin);
#endif
	inputData();
#if DEBUG
	printData(map);
#endif
	printf("%d\n", BFS());
	return 0;
}
#endif
