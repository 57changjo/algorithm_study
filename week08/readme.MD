# 📆 Week 8 스터디 정리

## 📌 주제
- 이번 주 주제: DP
- 출제자: 홍시은

---

## 📂 다룬 문제
1. [백준 9251 - LCS](https://www.acmicpc.net/problem/9251)
2. [백준 11048 - 이동하기](https://www.acmicpc.net/problem/11048)
3. [정올 1749 - 구슬게임](https://jungol.co.kr/problem/1749?cursor=MTAsOSww)

---

## 📊 발표 담당
- 문제 1: 조민창
- 문제 2: 김다경
- 문제 3: 박민우

---

## 📝 리뷰 요약

정리담당: 조윤서

문제 1 : DFS처럼 보이지만 실제로는 테이블 기반 DP 문제
dp[i][j]를 기준으로 왼쪽, 위, 대각선만 보면서 값을 채워나간다. 아직 계산되지 않은 아래쪽은 볼 필요가 없고, 이전 단계들만 참조. C++ 입출력에서는 std::ios::sync_with_stdio(false);와 std::cin.tie(NULL);을 사용해서 C의 stdio와 동기화를 끊어 속도를 향상시킬 수 있고 cout이 C의 printf와 같은 역할을 한다. 문자열을 다룰 때는 " "을 앞에 더해 1부터 인덱싱하기 쉽게 만들고 길이를 구할 때는 length() – 1로 처리

문제 2 : 2차원 DP와 vector 사용법에 중점
vector<vector<int>>를 이용하면 동적할당으로 크기를 지정할 수 있고, resize()를 통해 행과 열의 크기를 설정한 뒤 사탕 개수를 입력받음. dp 배열은 i, j번째 위치에 도착하기까지의 최대 사탕 수를 저장하며, 위쪽·왼쪽·대각선 방향 중 가장 큰 값을 선택하고 현재 위치의 사탕 수를 더해나가는 방식. 

문제 3 : 시뮬레이션과 DP가 결합된 승패 판정 문제
A와 B가 번갈아 돌을 가져가는 상황에서 A가 항상 최선의 수를 둔다고 가정한다. bool dp를 사용해 각 상태에서 A가 이길 수 있는지를 저장하며, 가능한 선택지(b1, b2, b3) 중 하나라도 상대를 지는 상태로 만들 수 있다면 canWin을 true로 설정. 즉, A가 현재 턴에서 상대를 패배시키는 수를 만들 수 있으면 그 상태는 승리 상태다. 반대로 모든 경우가 막혀 있으면 패배 상태로 둔다.
---

## 📚 추가 학습/참고
- 시뮬레이션 유형 및 C++

---

## ✅ 다음주 문제 출제자: 최현준

- 다음 주 주제: 
- 문제 번호 및 링크:
1. [백준 11399 - ATM](https://www.acmicpc.net/problem/11399)
2. [백준 10162 - 전자레인지](https://www.acmicpc.net/problem/10162)
3. [백준 14891 - 톱니바퀴](https://www.acmicpc.net/problem/14891)
4. [백준 2961 - 도영이가 만든 맛있는 음식](https://www.acmicpc.net/problem/2961)
