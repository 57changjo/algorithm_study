# 📆 Week 10 스터디 정리

## 📌 주제
- 이번 주 주제: DP
- 출제자: 조윤서

---

## 📂 다룬 문제
1. [백준 2579 - 계단오르기](https://www.acmicpc.net/problem/2579)
2. [백준 15486 - 퇴사2](https://www.acmicpc.net/problem/15486)
3. [백준 16236 - 아기상어](https://www.acmicpc.net/problem/16236)
---

## 📊 발표 담당
- 문제 1: 홍시은
- 문제 2: 전진
- 문제 3: 조민창

---

## 📝 리뷰 요약
- 정리담당: 김다경
### 문제 1: 계단오르기
- 풀이 접근: DP[i]에 i번째 계단까지 올랐을 때 얻을 수 있는 최대 점수를 저장한다. 3칸을 연속해서 오를 수 없기 때문에 i-2에서 한 칸 건너뛰고 i로 온 경우( DP[i - 2] + stair[i] )와 i-3 → i-1 → i로 온 경우( DP[i - 3] + stair[i - 1] + stair[i] ) 두가지 경우로만 점수를 계산할 수 있다. 따라서 두 값 중 큰 값을 DP에 저장한다.
- 주요 코드/아이디어: i-3에서 뛰면 3칸 연속 불가라는 조건을 해결할 수 있다. 또한, 1,2,3 칸 오를 때는 규칙을 대입하기 너무 적어서 따로 작성해야한다.
- 리뷰 포인트: 입력과 풀이부분을 분리하면 좋겠다. 해당 풀이는 N=1, 2일때는 문제가 될 수 있어서 다른 방법도 고민해보면 좋겠다.

### 문제 2: 퇴사2
- 풀이 접근: dp에 i번째 날에 최대로 받을 수 있는 돈을 저장한다. 따라서 i번째 날에 일을 한다면, dp[i + T[i]]에 dp[i] + P[i] 와 dp[i + T[i]] 중 최대값을 저장한다. I번째 날에 일을 안한다면, dp[i + 1]에 dp[i]와 dp[i + 1] 중 큰 값을 저장한다. 이후, 1일차부터 N일차까지 일을 할지 말지 비교하면서 dp를 계산한다. 그럼 그 결과가 N+1과 동일하여 N+1 번째 dp를 출력하면 된다.
- 주요 코드/아이디어: i 번째 날에 일을 할때, 일을 하지 않을때의 최대값을 각각 저장한다.
- 리뷰 포인트: 처음부터 dp[i + 1]과 dp[i + T[i]]를 저장하면 다시 되돌아갈 필요가 없다.

### 문제 3: 아기상어
- 풀이 접근: 물고기의 위치(r, c)와 거리(dist)를 갖는 Target 구조체를 만들고 두 target a, b 사이의 거리와 위치를 비교하여 a가 b보다 먼저 먹히면 true, 아니면 false를 반환하는 compareTargets 함수를 만든다.
Bool 타입을 리턴하는 FindandEatFish 함수를 돌리며 리턴값이 false일때 총 시간을 출력한다.
FindandEatFish 함수는 시작점으로부터 거리를 체크하며 map 전체의 먹을 수 있는 물고기를 candidates 배열에 넣는다. 물고기를 다 찾은 후에는 compareTargets 함수를 기반으로 candidates 배열을 sorting 하고, 가장 가까운 물고리를 먹는다. 이 동작은 더이상 먹을 물고기가 없을 때까지 반복된다.
- 주요 코드/아이디어: BFS를 활용해서 먹을 수 있는 물고기와 거리를 계산함. 먹을 수 있는 물고기는 일단 후보 list에 추가하고, 나중에 정렬하여 우선순위가 가장 높은 물고기를 찾음.
- 리뷰 포인트: 물고기의 위치와 거리를 하나의 구조체로 만들고 compareTargets 함수를 활용하여 정렬해서 조건을 만족하는 물고기를 명확하게 선택함.

---

## 📚 추가 학습/참고
- 
- 

---

## ✅ 다음주 문제 출제자: 박민우
- 다음 주 주제:
- 문제 번호 및 링크:
  1. 문제 1: [백준 1446 - 지름길] https://www.acmicpc.net/problem/1446
  2. 문제 2: [백준 2110 - 공유기 설치] https://www.acmicpc.net/problem/2110
  3. 문제 3: [백준 2458 - 키 순서] https://www.acmicpc.net/problem/2458
