#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>

#define MAX_N (25+2)

typedef struct _node {
	int gd_r, gd_c, gs_r, gs_c, t;
}node_t;
node_t Q[MAX_N * MAX_N * MAX_N* MAX_N];
int front, rear;

int map[MAX_N][MAX_N];
int visited[MAX_N][MAX_N][MAX_N][MAX_N];

int N;
int gd_sr, gd_sc, gdh_r, gdh_c;
int gs_sr, gs_sc, gsh_r, gsh_c;

void inputdata(void) {
	(void)scanf("%d", &N);
	(void)scanf("%d %d %d %d", &gd_sr, &gd_sc, &gdh_r, &gdh_c);
	(void)scanf("%d %d %d %d", &gs_sr, &gs_sc, &gsh_r, &gsh_c);
	for (int i = 1; i <= N; i++) {
		for (int j = 1; j <= N; j++) {
			(void)scanf("%d", map[i] + j);
		}
	}
}

void printdata(void) {
	for (int i = 1; i <= N; i++) {
		for (int j = 1; j <= N; j++) {
			printf("%d", map[i][j]);
		}
		printf("\n");
	}
	printf("\n");
}

int dr[9] = { 1,-1, 0, 0 ,1, -1, 1, -1, 0};
int dc[9] = { 0, 0, 1, -1, -1, 1, 1, -1, 0};

int BFS(void) {
	front = rear = 0;
	node_t current = { 0 };

	Q[rear++] = (node_t){ gd_sr,gd_sc,gs_sr,gs_sc, 0 };				//고돌이 고순이의 시작 위치 q[0]에 넣음
	visited[gd_sr][gd_sc][gs_sr][gs_sc] = 1;						//고돌이 고순이의 시작점 위치 visited에 표시
	int gd_nr, gd_nc;
	int gs_nr, gs_nc;
	while (front != rear) {
		current = Q[front++];
		for (int i = 0; i < 9; ++i) {
			for (int j = 0; j < 9; ++j) {
				if (i == 8 && j == 8) continue;
				gd_nr = current.gd_r + dr[i];
				gd_nc = current.gd_c + dc[i];
				gs_nr = current.gs_r + dr[j];
				gs_nc = current.gs_c + dc[j];
				if (visited[gd_nr][gd_nc][gs_nr][gs_nc]) continue;																								                                   	//방문한 경우
				if (gd_nr == gdh_r && gd_nc == gdh_c && gs_nr == gsh_r && gs_nc == gsh_c) return current.t + 1;													            	//집에 도착한경우
				if (map[gd_nr][gd_nc] || map[gs_nr][gs_nc]) continue;																							                                    //웅덩이
				if (gd_nr > N || gd_nr <= 0 || gd_nc > N || gd_nc <= 0 || gs_nr > N || gs_nr <= 0 || gs_nc > N || gs_nc <= 0) continue;								//테두리 밖인 경우
				if ((abs(gd_nr - gs_nr) <= 1) && (abs(gd_nc - gs_nc) <= 1)) continue;																				                          //근접해 있을 경우
				Q[rear++] = (node_t){ gd_nr, gd_nc, gs_nr, gs_nc, current.t + 1 };  
				visited[gd_nr][gd_nc][gs_nr][gs_nc] = 1;
			}
		}
	}
	return 0;
}

int main(void) {
	(void)freopen("prob2.txt", "r", stdin);
	inputdata();
	printf("%d\n", BFS());

	printdata();
}
