# 📆 Week 1 스터디 정리

## 📌 주제
- 이번 주 주제: DFS
- 출제자: 조민창

---

## 📂 다룬 문제
1. [백준 2606 - 바이러스](https://www.acmicpc.net/problem/2606)
2. [백준 11724 - 연결 요소의 개수](https://www.acmicpc.net/problem/11724)
3. [백준 3273 - 두 수의 합](https://www.acmicpc.net/problem/3273)

---

## 📊 발표 담당
- 문제 1: 김다경
- 문제 2: 박민우
- 문제 3: 조윤서

---

## 📝 리뷰 요약
- 정리담당: 최현준
### 문제 1: (백준 2606 - 바이러스) / 발표자 : 김다경
- 풀이 접근: BFS 중심 풀이
- 주요 코드/아이디어: vistied를 선언해 map을 [m][2]의 크기로 선언하여 [0]을 검사하고 [1]을 배열에 저장함. / 홍시은 : 인접행렬 사용하여 풀이
- 리뷰 포인트:
      - scanf함수는 한 줄에 쓸 수 있으면 써서 여러번 호출 안하는 것이 좋음.
      - scanf 전 배열 초기화를 통해 오류 예방

### 문제 2: (백준 11724 - 연결 요소의 개수) / 발표자 : 박민우
- 풀이 접근: DFS 중심 풀이
- 주요 코드/아이디어: 방향없는 그래프를 생성해 순서쌍이 연결된 것을 1로 표시하여 풀이함. 0인 요소를 만나면 map에 1 표시하고 count++하고 재귀, 최종으로 return
                    조민창 : checknext라는 함수를 선언하여 main의 while문 종료조건 구현 
- 리뷰 포인트: cnt가 언제 count되는지가 1번 문제와 2번 문제의 차이. 1번 문제의 변형편이라 큰 차이는 없음
      

### 문제 3: (백준 3273 - 두 수의 합)
- 풀이 접근: 2중 for문시 시간복잡도 증대로 제한시간 내 풀이 불가 -> 배열의 양쪽 끝에서 서로 읽어들어가는 로직(two 포인터 algorithm)
- 주요 코드/아이디어: 2중 for문 생성시 시간복잡도가 증대하므로 배열의 양 끝을 합해서 문제의 요구 sum보다 크면 큰 쪽에서 커서를 작은 쪽으로, sum보다 작으면 작은 쪽에서 커서를 큰 쪽으로 이동하며 배열을 훑음 => 시간복잡도 감소 가능
                  홍시은 : x(문제의 요구 sum)을 나누어 x/2를 기준으로 배열의 양쪽 끝까지 가는 커서를 구현함(시간복잡도는 똑같이 N^2이나, 계수가 매우 낮아 통과)
- 리뷰 포인트: two 포인터 기법은 굉장히 많은 algorithm문제에서 쓰기 때문에 알아두면 좋다!!

---

## 📚 추가 학습/참고
- 시간복잡도 개념 추가 학습
- 

---

## ✅ 다음주 문제 출제자: 홍시은
- 다음 주 주제: 
- 문제 번호 및 링크:
  1. 문제 1: [백준 문제번호 - 문제명](문제링크)
  2. 문제 2: [백준 문제번호 - 문제명](문제링크)
  3. 문제 3: [백준 문제번호 - 문제명](문제링크)
